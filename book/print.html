<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="what_is_chalk.html"><strong aria-hidden="true">1.</strong> What is Chalk?</a></li><li><ol class="section"><li class="expanded "><a href="what_is_chalk/crates.html"><strong aria-hidden="true">1.1.</strong> Crates</a></li></ol></li><li class="expanded "><a href="contribution_guide.html"><strong aria-hidden="true">2.</strong> Contribution guide</a></li><li class="expanded "><a href="repl.html"><strong aria-hidden="true">3.</strong> REPL</a></li><li class="expanded "><a href="types.html"><strong aria-hidden="true">4.</strong> Representing and manipulating Rust types</a></li><li><ol class="section"><li class="expanded "><a href="types/role_of_type_family.html"><strong aria-hidden="true">4.1.</strong> The role of the TypeFamily</a></li><li class="expanded "><a href="types/how_to_control_repr.html"><strong aria-hidden="true">4.2.</strong> Controlling representation with TypeFamily</a></li><li class="expanded "><a href="types/rust_types.html"><strong aria-hidden="true">4.3.</strong> Rust types</a></li><li><ol class="section"><li class="expanded "><a href="types/rust_types/application_ty.html"><strong aria-hidden="true">4.3.1.</strong> Application types</a></li></ol></li><li class="expanded "><a href="types/rust_lifetimes.html"><strong aria-hidden="true">4.4.</strong> Rust lifetimes</a></li><li class="expanded "><a href="types/operations.html"><strong aria-hidden="true">4.5.</strong> Operations</a></li><li><ol class="section"><li class="expanded "><a href="types/operations/fold.html"><strong aria-hidden="true">4.5.1.</strong> Fold and the Folder trait</a></li></ol></li></ol></li><li class="expanded "><a href="rust_ir.html"><strong aria-hidden="true">5.</strong> Representing traits, impls, and other parts of Rust programs</a></li><li class="expanded "><a href="clauses.html"><strong aria-hidden="true">6.</strong> Lowering Rust IR to logic</a></li><li><ol class="section"><li class="expanded "><a href="clauses/type_equality.html"><strong aria-hidden="true">6.1.</strong> Unification and type equality</a></li></ol></li><li class="expanded "><a href="engine.html"><strong aria-hidden="true">7.</strong> How does the engine work</a></li><li class="expanded "><a href="glossary.html"><strong aria-hidden="true">8.</strong> Glossary and terminology</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-is-chalk" id="what-is-chalk">What is Chalk?</a></h1>
<h1><a class="header" href="#crate-breakdown" id="crate-breakdown">Crate breakdown</a></h1>
<p>Chalk is broken up into a number of crates. This chapter explains the
role of each crate. This crate structure helps to serve Chalk's two goals:</p>
<ul>
<li>To serve as the trait engine for compilers and tools like rustc and rust-analyzer</li>
<li>To be usable as a standalone REPL and testing harness</li>
</ul>
<h2><a class="header" href="#crates-for-embedding-chalk-into-other-programs" id="crates-for-embedding-chalk-into-other-programs">Crates for embedding chalk into other programs</a></h2>
<p>The following crates are &quot;public facing&quot; crates that you may use when embedding chalk into
other programs:</p>
<ul>
<li>The <code>chalk-solve</code> crate, which defines the rules that translate Rust IR into logical predicates.</li>
<li>The <code>chalk-ir</code> crate, which defines the IR representing types and logical predicates.</li>
<li>The <code>chalk-rust-ir</code> crate, which defines the IR representing Rust concepts like traits and impls.</li>
</ul>
<p>The following crate is an implementation detail, used internally by <code>chalk-solve</code>:</p>
<ul>
<li>The <code>chalk-engine</code> crate, which defines the actual engine that solves logical predicate. This 
engine is quite general and not really specific to Rust.</li>
<li>The <code>chalk-derive</code> crate defines custom derives for the <code>chalk_ir::fold::Fold</code> trait and other
such things.</li>
<li>The <code>chalk-macros</code> crate defines a few miscellaneous utility macros.</li>
</ul>
<h2><a class="header" href="#crates-for-standalone-repl-and-testing" id="crates-for-standalone-repl-and-testing">Crates for standalone REPL and testing</a></h2>
<p>The following crates are used to define the REPL and internal testing
harness. These crates build on the crates above. Essentially, they
define a kind of &quot;minimal embedding&quot; of chalk.</p>
<ul>
<li>The <code>chalk-parser</code> crate can parse Rust syntax to product an AST.</li>
<li>The <code>chalk-integration</code> crate can take that AST and use it to drive
the <code>chalk-solve</code> crate above. The AST is converted into
<code>chalk-rust-ir</code> by a process called &quot;lowering'.</li>
<li>Finally, the main <code>chalk</code> crate, along with the testing crate in the
<code>tests</code> directory, define the actual entry points.</li>
</ul>
<h1><a class="header" href="#contribution-guide" id="contribution-guide">Contribution guide</a></h1>
<h1><a class="header" href="#repl" id="repl">REPL</a></h1>
<h1><a class="header" href="#representing-and-manipulating-rust-types" id="representing-and-manipulating-rust-types">Representing and manipulating Rust types</a></h1>
<h2><a class="header" href="#goal-of-the-chalk-ir-crate" id="goal-of-the-chalk-ir-crate">Goal of the chalk-ir crate</a></h2>
<p>To have an ergonomic, flexible library that can abstractly represent
Rust types and logical predicates. The library should be expose a
&quot;minimal&quot; set of types that is nonetheless able to capture the full
range of Rust types. &quot;Minimal&quot; here means that some of the surface
differences in Rust types -- e.g., the distinction between built-in
types like <code>u32</code> and user-defined types like a struct -- ought to be
minimized, so that code that works with these types (e.g., trait
solving) can focus on the most important differences.</p>
<h2><a class="header" href="#goal-support-embedding-and-a-variety-of-contexts" id="goal-support-embedding-and-a-variety-of-contexts">Goal: support embedding and a variety of contexts</a></h2>
<p>One of our goals is to create a type representation that can be
readily embedded into a variety of contexts. Most specifically, we
would like to be able to embed into rustc and rust-analyzer, and
permit those two projects to use distinct memory management
strategies. This is primarily achieved via the <code>TypeFamily</code> trait.</p>
<p>Initially, at least in rustc, the goal is to be able to easily and
&quot;reasonably efficiently&quot; convert back and forth between rustc's native
type representation and chalk's representation. Once chalk's design
has stabilized, however, the goal would be for rustc to adopt this
format as its &quot;native&quot; representation.</p>
<p>Note that even if the chalk type library were used everywhere,
however, it would still be useful for rustc to be able to control the
memory management strategy. (In other words, different consumers might
wish to use it in different ways.)</p>
<h2><a class="header" href="#note-on-status" id="note-on-status">Note on status</a></h2>
<p>At the moment, this documentation is a &quot;proposal&quot;. That means that it
diverges in some places from what is actually implemented. It has also
not been thoroughly discussed by the Rust compiler team as a whole.</p>
<p>Here is a (partial) list of some things that have to be adapted in
Chalk as of today to match this document:</p>
<ul>
<li><code>Parameter&lt;TF&gt;</code> needs to be renamed to <code>GenericArgument</code></li>
<li><code>Vec&lt;Parameter&lt;TF&gt;&gt;</code> needs to be replaced with <code>GenericArguments</code></li>
<li>Extract <code>TypeName</code> into something opaque to chalk-ir.</li>
<li>Dyn type equality should probably be driven by entailment.</li>
<li>Projections need to be renamed to aliases.</li>
<li>The variant we use for impl traits should be removed and folded into type aliases. </li>
<li>Remove placeholders and projection placeholders from apply and create placeholder types.</li>
<li>Move <code>Error</code> from a <code>TypeName</code> to its own variant.</li>
<li>Introduce <code>GeneratorWitness</code> into chalk</li>
<li>Complete transition from <code>ForAll</code> to <code>Fn</code> in chalk </li>
</ul>
<h2><a class="header" href="#the-role-of-the-typefamily" id="the-role-of-the-typefamily">The role of the <code>TypeFamily</code></a></h2>
<p>Most everything in the IR is parameterized by the <a href="http://rust-lang.github.io/chalk/chalk_ir/family/trait.TypeFamily.html"><code>TypeFamily</code></a> trait:</p>
<pre><code class="language-rust ignore">trait TypeFamily: Copy + Clone + Debug + Eq + Ord { 
    ..
}
</code></pre>
<p>We'll go over the details later, but for now it suffices to say that
the type family is defined by the embedded and can be used to control
(to a certain extent) the actual representation of types, goals, and
other things in memory. For example, the <code>TypeFamily</code> trait could be
used to intern all the types, as rustc does, or it could be used to
<code>Box</code> them instead, as the chalk testing harness currently does.</p>
<h3><a class="header" href="#controlling-representation-with-typefamily" id="controlling-representation-with-typefamily">Controlling representation with <code>TypeFamily</code></a></h3>
<p>The purpose of the <a href="http://rust-lang.github.io/chalk/chalk_ir/family/trait.TypeFamily.html"><code>TypeFamily</code></a> trait is to give control over how
types and other bits of chalk-ir are represented in memory. This is
done via an &quot;indirection&quot; strategy. We'll explain that strategy here
in terms of <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty</code></a> and <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TyData.html"><code>TyData</code></a>, the two types used to represent
Rust types, but the same pattern is repeated for many other things.</p>
<p>Types are represented by a <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty&lt;TF&gt;</code></a> type and the <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TyData.html"><code>TyData&lt;TF&gt;</code></a> enum.
There is no <em>direct</em> connection between them. The link is rather made
by the <a href="http://rust-lang.github.io/chalk/chalk_ir/family/trait.TypeFamily.html"><code>TypeFamily</code></a> trait, via the <a href="http://rust-lang.github.io/chalk/chalk_ir/family/trait.TypeFamily.html#associatedtype.InternedType"><code>InternedTy</code></a> associated type:</p>
<pre><code class="language-rust ignore">struct Ty&lt;TF: TypeFamily&gt;(TF::InternedTy);
enum TyData&lt;TF: TypeFamily&gt; { .. }
</code></pre>
<p>The way this works is that the <a href="http://rust-lang.github.io/chalk/chalk_ir/family/trait.TypeFamily.html"><code>TypeFamily</code></a> trait has an associated
type <a href="http://rust-lang.github.io/chalk/chalk_ir/family/trait.TypeFamily.html#associatedtype.InternedType"><code>InternedTy</code></a> and two related methods, <a href="http://rust-lang.github.io/chalk/chalk_ir/family/trait.TypeFamily.html#tymethod.intern_ty"><code>intern_ty</code></a> and <a href="http://rust-lang.github.io/chalk/chalk_ir/family/trait.TypeFamily.html#tymethod.ty_data"><code>ty_data</code></a>:</p>
<pre><code class="language-rust ignore">trait TypeFamily {
    type InternedTy;
    
    fn intern_ty(&amp;self, data: &amp;TyData&lt;Self&gt;) -&gt; Self::InternedTy;
    fn ty_data(data: &amp;Self::InternedTy) -&gt; &amp;TyData&lt;Self&gt;;
}
</code></pre>
<p>However, as a user you are not meant to use these directly. Rather,
they are encapsulated in methods on the <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty</code></a> and <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TyData.html"><code>TyData</code></a> types:</p>
<pre><code class="language-rust ignore">impl&lt;TF: TypeFamily&gt; Ty&lt;TF&gt; {
  fn data(&amp;self) -&gt; &amp;TyData&lt;TF&gt; {
    TF::lookup_ty(self)
  }
}
</code></pre>
<p>and</p>
<pre><code class="language-rust ignore">impl&lt;TF: TypeFamily&gt; TyData&lt;TF&gt; {
  fn intern(&amp;self, tf: &amp;TF) -&gt; Ty&lt;TF&gt; {
    Ty(tf.intern_ty(self))
  }
}
</code></pre>
<p>Note that there is an assumption here that <a href="http://rust-lang.github.io/chalk/chalk_ir/family/trait.TypeFamily.html#tymethod.ty_data"><code>ty_data</code></a> needs no
context. This effectively constrains the <a href="http://rust-lang.github.io/chalk/chalk_ir/family/trait.TypeFamily.html#associatedtype.InternedType"><code>InternedTy</code></a> representation
to be a <code>Box</code> or <code>&amp;</code> type. To be more general, at the cost of some
convenience, we could make that a method as well, so that one would
invoke <code>ty.data(tf)</code> instead of just <code>ty.data()</code>. This would permit us
to use (for example) integers to represent interned types, which might
be nice (e.g., to permit using generational indices).</p>
<h1><a class="header" href="#rust-types" id="rust-types">Rust types</a></h1>
<p>Rust types are represented by the <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty</code></a> and <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TyData.html"><code>TyData</code></a> types.
You use <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html"><code>Ty</code></a> to represent &quot;some Rust type&quot;. But to actually inspect
what sort of type you have, you invoke the <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.Ty.html#method.data"><code>data</code></a> method, which
returns a <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TyData.html"><code>TyData</code></a>. As described earlier, the actual in-memory
representation of types is controlled by the <a href="http://rust-lang.github.io/chalk/chalk_ir/family/trait.TypeFamily.html"><code>TypeFamily</code></a> trait.</p>
<h2><a class="header" href="#the-tydata-variants-and-how-they-map-to-rust-syntax" id="the-tydata-variants-and-how-they-map-to-rust-syntax">The <code>TyData</code> variants and how they map to Rust syntax</a></h2>
<p>This section covers the variants we use to categorize types. We have
endeavored to create a breakdown that simplifies the Rust &quot;surface
syntax&quot; of types to their &quot;essence&quot;. In particular, the goal is to
group together types that are largely treated identically by the
system and to separate types when there are important semantic
differences in how they are handled.</p>
<table><thead><tr><th>Chalk variant</th><th>Example Rust types</th></tr></thead><tbody>
<tr><td><code>Apply</code></td><td><code>Vec&lt;u32&gt;</code>, <code>f32</code></td></tr>
<tr><td><code>Placeholder</code></td><td>how we represent <code>T</code> when type checking <code>fn foo&lt;T&gt;() { .. }</code></td></tr>
<tr><td><code>Dyn</code></td><td><code>dyn Trait</code></td></tr>
<tr><td><code>Fn</code></td><td><code>fn(&amp;u8)</code></td></tr>
<tr><td><code>Alias</code></td><td><code>&lt;T as Iterator&gt;::Item</code>, or the <code>Foo</code> in <code>type Foo = impl Trait</code> and <code>type Foo = u32</code></td></tr>
<tr><td><code>BoundVariable</code></td><td>an uninstantiated generic parameter like the <code>T</code> in <code>struct Foo&lt;T&gt;</code></td></tr>
</tbody></table>
<h2><a class="header" href="#justification-for-each-variant" id="justification-for-each-variant">Justification for each variant</a></h2>
<p>Each variant of <code>TyData</code> generally wraps a single struct, which
represents a type known to be of that particular variant. This section
goes through the variants in a bit more detail, and in particular
describes why each variant exists.</p>
<h3><a class="header" href="#application-types" id="application-types">Application types</a></h3>
<p>The <code>Apply</code> variant contains an <code>ApplicationTy</code>. These are kind of the
&quot;normal Rust types&quot;, like <code>Vec&lt;u32&gt;</code> or <code>f32</code>. They consist of a &quot;type
name&quot; (in our examples, <code>Vec</code> and <code>f32</code> respecively) and zero or more
generic arguments (respectively, <code>[u32]</code> and <code>[]</code>).</p>
<p>They are equal to other types (modulo aliases, see below) iff they
have the same &quot;type name&quot; and the generic arguments are
recursively equal</p>
<h3><a class="header" href="#placeholders" id="placeholders">Placeholders</a></h3>
<p>The <code>Placeholder</code> variant contains a <code>PlaceholderIndex</code> type. It
represents a generic type that is being treated abstractly or -- more
generally -- the result of a &quot;type function&quot; that cannot be
evaluated. For example, when typing the body of a generic function
like <code>fn foo&lt;T: Iterator&gt;</code>, the type <code>T</code> would be represented with a
placeholder. Similarly, in that same function, the associated type
<code>T::Item</code> might be represented with a placeholder.</p>
<p>Like application types, placeholder <em>types</em> are only known to be
equal.</p>
<p>However, we choose not to represent placeholder types as type names
because they need to be created during type unification and other
operations, and hence that would require treating <code>TypeName</code> less opaquely.</p>
<p>Moreover, when proving negative goals, e.g., <code>not { Implemented(T: Trait) }</code>, placeholders are treated quite differently from application
types, since they do not (in fact) represent a known type. When
solving negative goals, placeholderes are replaced with inference
variables -- the idea is that this goal is only true if there is <em>no
type</em> <code>T</code> that implements <code>Trait</code>. Therefore, if we can find no
answeres for <code>exists&lt;T&gt; { Implemented(T: Trait) }</code>, then we know that
the negation is true. (Note that this means that e.g. <code>forall&lt;X&gt; { X = i32 }</code> is false but so is <code>forall&lt;X&gt; { not { X = i32 } }</code>.)</p>
<h3><a class="header" href="#inference-variables" id="inference-variables">Inference variables</a></h3>
<p>The <code>InferenceVar</code> variant wraps an <code>InferenceVar</code> type.  This
represents a type whose value is being inferred. The value of an
inference variables may be &quot;known&quot; or &quot;not known&quot;, but that state is
stored externally, in the inference context (see the section on
inference below).</p>
<p>When equating, inference variables are treated specially in that they
become bound (or, if they have already been bound, they are replaced
with their value).</p>
<p>Inference variables are also integral to canonicalization and
other types.</p>
<h3><a class="header" href="#dyn-types" id="dyn-types">Dyn types</a></h3>
<p>The <code>Dyn</code> variant wraps a <code>DynTy</code> and represents a <code>dyn Trait</code>
type. In chalk, these are represented as an existential type where we
store the predicates that are known to be true. So a type like <code>dyn Write</code> would be represented as, effectively, an <code>exists&lt;T&gt; { T: Write }</code> type.</p>
<p>When equating, two <code>dyn P</code> and <code>dyn Q</code> types are equal if <code>P = Q</code> --
i.e., they have the same bounds. Note that -- for this purpose --
ordering of bounds is significant. That means that if you create a
<code>dyn Foo + Send</code> and a <code>dyn Send + Foo</code>, chalk would consider them
distinct types. The assumption is that bounds are ordered in some
canonical fashion somewhere else. This may want to change.</p>
<p>There are &quot;automatic&quot; rules for proving that <code>dyn P: P</code> and so forth, but
that is outside the scope of the chalk-ir crate.</p>
<h3><a class="header" href="#function-pointer-types" id="function-pointer-types">Function pointer types</a></h3>
<p>The <code>Fn</code> variant wraps a <code>FnTy</code> struct and represents a <code>fn()</code> type
(in other words, a function pointer). In some ways, fn types are like
application types, but with one crucial difference: they also contain
a <code>forall</code> binder that for lifetimes whose value is determined when
the function is called. Consider e.g. a type like <code>fn(&amp;u32)</code> or --
more explicitly -- <code>for&lt;'a&gt; fn(&amp;'a u32)</code>.</p>
<p>Two <code>Fn</code> types <code>A, B</code> are equal <code>A = B</code> if <code>A &lt;: B</code> and <code>B &lt;: A</code></p>
<p>Two <code>Fn</code> types <code>A, B</code> are subtypes <code>A &lt;: B</code> if</p>
<ul>
<li>After instantiating the lifetime parameters on <code>B</code> universally...
<ul>
<li>You can instantiate the lifetime parameters on <code>A</code> existentially...
<ul>
<li>And then you find that <code>P_B &lt;: P_A</code> for every parameter type <code>P</code> on <code>A</code> and <code>B</code> and
<code>R_A &lt;: R_B</code> for the return type <code>R</code> of <code>A</code> and <code>B</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>We currently handle type inference with a bit of a hack (same as
rustc); when relating a <code>Fn</code> type <code>F</code> to an unbounded type
variable <code>V</code>, we instantiate <code>V</code> with <code>F</code>.  But in practice
because of the above subtyping rules there are actually a range of
values that <code>V</code> could have and still be equal with <code>F</code>. This may
or may not be something to consider revisiting.</p>
<h3><a class="header" href="#generator-witness-types" id="generator-witness-types">Generator witness types</a></h3>
<p>The <code>GeneratorWitness</code> variant wraps a <code>GeneratorWitness</code> type.  These
witnesses represent the types that may be part of a generator
state. Unlike other types, witnesses include bound, existential
lifetimes, which refer to lifetimes within the suspended stack frame.
You can think of it as a type like <code>exists&lt;'a&gt; { (T...) }</code>.</p>
<p>Witnesses are very similar to an <code>Apply</code> type, but it has a binder for
the erased lifetime(s), which must be handled specifically in equating
and so forth. In many ways, witnesses are also quite similar to <code>Fn</code>
types, and it is not out of the question that these two could be
unified; however, they are quite distinct semantically and so that
would be an annoying mismatch in other parts of the system.
Witnesses are also similar to a <code>Dyn</code> type, in that they represent an
existential type, but in contrast to <code>Dyn</code>, what we know here is
not a <em>predicate</em> but rather some upper bound on the set of types
contained within.</p>
<h3><a class="header" href="#alias-types" id="alias-types">Alias types</a></h3>
<p>The <code>Alias</code> variant wraps an <code>AliasTy</code> and is used to represent some form of <em>type
alias</em>. These correspond to associated type projections like <code>&lt;T as Iterator&gt;::Item</code>
but also <code>impl Trait</code> types and named type aliases like <code>type Foo&lt;X&gt; = Vec&lt;X&gt;</code>. </p>
<p>Each alias has an alias id as well as parameters. Aliases effectively
represent a <em>type function</em>.</p>
<p>Aliases are quite special when equating types. In general, an alias
type <code>A</code> can also be equal to <em>any other type</em> <code>T</code> if evaluating the
alias <code>A</code> yields <code>T</code> (this is currently handled in Chalk via a
<code>ProjectionEq</code> goal, but it would be renamed to <code>AliasEq</code> under this
proposal).</p>
<p>However, some alias types can also be instantiated as &quot;alias
placeholders&quot;. This occurs when the precise type of the alias is not
known, but we know that there is <em>some type</em> that it evaluates to (for
example, <code>&lt;T as Iterator&gt;::Item</code> might be treated opaquely as
<code>T::Item</code>; similarly <code>impl Trait</code> types are treated opaquely until the
latter phases of the compiler). Alias placeholders are not represented
with the <code>Alias</code> variant, but rather with the placeholder variant
described previously.</p>
<h3><a class="header" href="#bound-variables" id="bound-variables">Bound variables</a></h3>
<p>The <code>BoundVariable</code> variant represents some variable that is bound in
an outer term. For example, given a term like <code>forall&lt;X&gt; { Implemented(X: Trait) }</code>, the <code>X</code> is bound. Bound variables in chalk
(like rustc) use de bruijin indices (See below).</p>
<p>Bound variables are never directly equated, as any bound variables would have
been instantiated with either inference variables or placeholders.</p>
<p>They do appear in canonical forms and other terms that contain binders.</p>
<h3><a class="header" href="#error-types" id="error-types">Error types</a></h3>
<p>The <code>Error</code> variant represents a type that resulted from some
erroneous expression. Error types generally propagate eagerly in an
attempt to suppress nonsense errors that are derived by interactions
with buggy code.</p>
<p><code>Error</code> should be its own variant because most bits of code will want
to handle it somewhat specially -- e.g., maybe it can &quot;unify&quot; with any
other type without any effect, and so forth.</p>
<h2><a class="header" href="#mapping-to-rustc-types" id="mapping-to-rustc-types">Mapping to rustc types</a></h2>
<p>The rustc <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/enum.TyKind.html"><code>TyKind</code></a> enum has a lot more variants than chalk. This
section describes how the rustc types can be mapped to chalk
types. The intention is that, at least when transitioning, rustc would
implement the <code>TypeFamily</code> trait and would map from the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/enum.TyKind.html"><code>TyKind</code></a>
enum to chalk's <code>TyData</code> on the fly, when <code>data()</code> is invoked.</p>
<p>This section describes how each of rustc's variants can be mapped to
Chalk variants.</p>
<table><thead><tr><th>rustc type</th><th>chalk variant (and some notes)</th></tr></thead><tbody>
<tr><td><code>Bool</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Char</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Int(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Uint(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Float(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Adt(_, _)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Foreign(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Str</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Array(_, _)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Slice(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>RawPtr(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Ref(_, _, _)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>FnDef(_, _)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>FnPtr(_, _)</code></td><td><code>Fn</code></td></tr>
<tr><td><code>Dynamic(_, _)</code></td><td><code>Dyn</code></td></tr>
<tr><td><code>Closure(_, _)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Generator(_, _)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>GeneratorWitness(_)</code></td><td><code>GeneratorWitness</code></td></tr>
<tr><td><code>Never</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Tuple(_)</code></td><td><code>Apply</code></td></tr>
<tr><td><code>Projection(_)</code></td><td><code>Alias</code></td></tr>
<tr><td><code>UnnormalizedProjection(_)</code></td><td>(see below)</td></tr>
<tr><td><code>Opaque(_, _)</code></td><td><code>Alias</code></td></tr>
<tr><td><code>Param(_)</code></td><td>XXX Placeholder?</td></tr>
<tr><td><code>Bound(_, _)</code></td><td><code>BoundVariable</code></td></tr>
<tr><td><code>Placeholder(_)</code></td><td><code>Placeholder</code></td></tr>
<tr><td><code>Infer(_)</code></td><td><code>InferenceVar</code></td></tr>
<tr><td><code>Error</code></td><td><code>Error</code></td></tr>
</tbody></table>
<h1><a class="header" href="#application-types-1" id="application-types-1">Application types</a></h1>
<p>An <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.ApplicationTy.html"><code>ApplicationTy</code></a> is kind of a &quot;normal Rust type&quot;, like
<code>Vec&lt;u32&gt;</code> or <code>f32</code>. Such types are only &quot;equal&quot; to themselves (modulo
aliases, see below), and they may take type arguments.  Note that we
group together <em>both</em> user-defined structs/enums/unions (like <code>Vec</code>)
as well as built-in types like <code>f32</code>, which effectively behave the
same.</p>
<p>An <a href="http://rust-lang.github.io/chalk/chalk_ir/struct.ApplicationTy.html"><code>ApplicationTy</code></a> contains two fields:</p>
<ul>
<li>a &quot;type name&quot; (of type <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TypeName.html"><code>TypeName</code></a>); and,</li>
<li>a list of generic arguments (of type <a href="types/rust_types/XXX"><code>GenericArguments</code></a>).</li>
</ul>
<p>The <a href="http://rust-lang.github.io/chalk/chalk_ir/enum.TypeName.html"><code>TypeName</code></a> itself is largely opaque to chalk. We discuss it in
more detail elsewhere. The point is that it represents, semantically,
either the name of some user-defined type (like <code>Vec</code>) or builtin-types
like <code>i32</code>. It may also represent types like &quot;tuple of arity 2&quot; (<code>(_, _)</code>) or &quot;fixed-length array&quot; <code>[_; _]</code>. Note that the precise set of
these built-in types is defined by the <code>TypeFamily</code> and is unknown to
chalk-ir.</p>
<h1><a class="header" href="#rust-lifetimes" id="rust-lifetimes">Rust lifetimes</a></h1>
<p>Lifetimes are represented by the <code>Lifetime&lt;TF&gt;</code> and <code>LifetimeData&lt;TF&gt;</code>
types. As with types, the actual representation of a lifetime is
defined by the associated type <code>TF::InternedLifetime</code>.</p>
<h3><a class="header" href="#the-lifetimedata-variants" id="the-lifetimedata-variants">The <code>LifetimeData</code> variants</a></h3>
<p>This section covers the variants we use to categorize lifetimes.</p>
<h4><a class="header" href="#variants-and-their-equivalents-in-rust-syntax" id="variants-and-their-equivalents-in-rust-syntax">Variants and their equivalents in Rust syntax</a></h4>
<table><thead><tr><th>Chalk variant</th><th>Example Rust types</th></tr></thead><tbody>
<tr><td><code>BoundVar</code></td><td>the <code>'a</code> in a type like <code>for&lt;'a&gt; fn(&amp;'a u8)</code>, before it is instantiated</td></tr>
<tr><td><code>InferenceVar</code></td><td>a lifetime whose value is being inferred</td></tr>
<tr><td><code>Placeholder</code></td><td>how we represent <code>'a</code> when type checking <code>fn foo&lt;'a&gt;() { .. }</code></td></tr>
<tr><td><code>Static</code></td><td>the lifetime <code>'static</code></td></tr>
</tbody></table>
<h1><a class="header" href="#operations" id="operations">Operations</a></h1>
<p>This chapter describes various patterns and utilities for manipulating
Rust types.</p>
<h1><a class="header" href="#fold-and-the-folder-trait" id="fold-and-the-folder-trait">Fold and the Folder trait</a></h1>
<p>The <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Fold.html"><code>Fold</code></a> trait permits one to traverse a type or other term in the
chalk-ir and make a copy of it, possibly making small substitutions or
alterations along the way. Folding also allows copying a term from one
type family to another.</p>
<p>To use the <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Fold.html"><code>Fold</code></a> trait, one invokes the <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Fold.html#tymethod.fold_with"><code>Fold::fold_with</code></a> method, supplying some
&quot;folder&quot; as well as the number of &quot;in scope binders&quot; for that term (typically <code>0</code>
to start):</p>
<pre><code class="language-rust ignore">let output_ty = input_ty.fold_with(&amp;mut folder, 0);
</code></pre>
<p>The folder is some instance of the <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Folder.html"><code>Folder</code></a> trait. This trait
defines a few key callbacks that allow you to substitute different
values as the fold proceeds. For example, when a type is folded, the
folder can substitute a new type in its place.</p>
<h2><a class="header" href="#uses-for-folders" id="uses-for-folders">Uses for folders</a></h2>
<p>A common use for <code>Fold</code> is to permit a substitution -- that is,
replacing generic type parameters with their values.</p>
<h2><a class="header" href="#from-fold-to-folder-to-superfold-and-back-again" id="from-fold-to-folder-to-superfold-and-back-again">From Fold to Folder to SuperFold and back again</a></h2>
<p>The overall flow of folding is like this.</p>
<ol>
<li><a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Fold.html#tymethod.fold_with"><code>Fold::fold_with</code></a> is invoked on the outermost term. It recursively
walks the term.</li>
<li>For those sorts of terms (types, lifetimes, goals, program clauses) that have
callbacks in the <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Folder.html"><code>Folder</code></a> trait, invoking <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Fold.html#tymethod.fold_with"><code>Fold::fold_with</code></a> will in turn
invoke the corresponding method on the <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Folder.html"><code>Folder</code></a> trait, such as <code>Folder::fold_ty</code>.</li>
<li>The default implementation of <code>Folder::fold_ty</code>, in turn, invokes
<code>SuperFold::super_fold_with</code>.  This will recursively fold the
contents of the type. In some cases, the <code>super_fold_with</code>
implementation invokes more specialized methods on <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Folder.html"><code>Folder</code></a>, such
as [<code>Folder::fold_free_var_ty</code>], which makes it easier to write
folders that just intercept <em>certain</em> types.</li>
</ol>
<p>Thus, as a user, you can customize folding by:</p>
<ul>
<li>Defining your own <code>Folder</code> type</li>
<li>Implementing the appropriate methods to &quot;intercept&quot; types/lifetimes/etc at the right level of
detail</li>
<li>In those methods, if you find a case where you would prefer not to
substitute a new value, then invoke <code>SuperFold::super_fold_with</code> to
return to the default behavior.</li>
</ul>
<h2><a class="header" href="#the-binders-argument" id="the-binders-argument">The <code>binders</code> argument</a></h2>
<p>Each callback in the <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Folder.html"><code>Folder</code></a> trait takes a <code>binders</code> argument. This indicates
the number of binders that we have traversed during folding, which is relevant for debruijn indices.
So e.g. a bound variable with depth 1, if invoked with a <code>binders</code> value of 1, indicates something that was bound to something external to the fold.</p>
<p>XXX explain with examples and in more detail</p>
<h2><a class="header" href="#the-foldresult-associated-type" id="the-foldresult-associated-type">The <code>Fold::Result</code> associated type</a></h2>
<p>The <code>Fold</code> trait defines a <a href="http://rust-lang.github.io/chalk/chalk_ir/fold/trait.Fold.html#associatedtype.Result"><code>Result</code></a> associated type, indicating the
type that will result from folding.</p>
<h2><a class="header" href="#when-to-implement-the-fold-and-superfold-traits" id="when-to-implement-the-fold-and-superfold-traits">When to implement the Fold and SuperFold traits</a></h2>
<p>Any piece of IR that represents a kind of &quot;term&quot; (e.g., a type, part
of a type, or a goal, etc) in the logic should implement <code>Fold</code>. We
also implement <code>Fold</code> for common collection types like <code>Vec</code> as well
as tuples, references, etc.</p>
<p>The <code>SuperFold</code> trait should only be implemented for those types that
have a callback defined on the <code>Folder</code> trait (e.g., types and
lifetimes).</p>
<h2><a class="header" href="#derives" id="derives">Derives</a></h2>
<p>Using the <code>chalk-derive</code> crate, you can auto-derive the <code>Fold</code> trait.
There isn't presently a derive for <code>SuperFold</code> since it is very rare
to require it. The derive for <code>Fold</code> is a bit cludgy and requires:</p>
<ul>
<li>You must import <code>Fold</code> into scope.</li>
<li>The type you are deriving <code>Fold</code> on must have either:
<ul>
<li>A type parameter that has a <code>TypeFamily</code> bound, like <code>TF: TypeFamily</code></li>
<li>A type parameter that has a <code>HasTypeFamily</code> bound, like <code>TF: HasTypeFamily</code></li>
<li>The <code>has_type_family(XXX)</code> attribute.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#representing-traits-impls-and-other-parts-of-rust-programs" id="representing-traits-impls-and-other-parts-of-rust-programs">Representing traits, impls, and other parts of Rust programs</a></h1>
<h1><a class="header" href="#lowering-rust-ir-to-logic" id="lowering-rust-ir-to-logic">Lowering Rust IR to logic</a></h1>
<h1><a class="header" href="#unification-and-type-equality" id="unification-and-type-equality">Unification and type equality</a></h1>
<h1><a class="header" href="#how-does-the-engine-work" id="how-does-the-engine-work">How does the engine work</a></h1>
<p><em>TBD:</em> Explain how chalk-engine </p>
<h1><a class="header" href="#glossary-and-terminology" id="glossary-and-terminology">Glossary and terminology</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
